/*
 * Copyright (C) 2011 Jamey Sharp
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */

#include <fftw3.h>
#include <stdio.h>

#define TRACE 0

struct signal_strength {
	double snr;
	double doppler;
	double phase;
};

static const struct SVDATA {
    int PRN, Navstar, T1, T2;
} SV[] = {
    {  1,  63,  2,  6, },
    {  2,  56,  3,  7, },
    {  3,  37,  4,  8, },
    {  4,  35,  5,  9, },
    {  5,  64,  1,  9, },
    {  6,  36,  2, 10, },
    {  7,  62,  1,  8, },
    {  8,  44,  2,  9, },
    {  9,  33,  3, 10, },
    { 10,  38,  2,  3, },
    { 11,  46,  3,  4, },
    { 12,  59,  5,  6, },
    { 13,  43,  6,  7, },
    { 14,  49,  7,  8, },
    { 15,  60,  8,  9, },
    { 16,  51,  9, 10, },
    { 17,  57,  1,  4, },
    { 18,  50,  2,  5, },
    { 19,  54,  3,  6, },
    { 20,  47,  4,  7, },
    { 21,  52,  5,  8, },
    { 22,  53,  6,  9, },
    { 23,  55,  1,  3, },
    { 24,  23,  4,  6, },
    { 25,  24,  5,  7, },
    { 26,  26,  6,  8, },
    { 27,  27,  7,  9, },
    { 28,  48,  8, 10, },
    { 29,  61,  1,  6, },
    { 30,  39,  2,  7, },
    { 31,  58,  3,  8, },
    { 32,  22,  4,  9, },
};

static const short ca_code_states[1023] = {
	0x7ff, 0x7fd, 0x7f9, 0x7f3, 0x7e5, 0x7cb, 0x797, 0x72d, 0x65b, 0x4b5,
	0x168, 0x2d2, 0x5a4, 0x34b, 0x695, 0x52b, 0x256, 0x4ae, 0x15e, 0x2bd,
	0x57a, 0x2f4, 0x5eb, 0x3d5, 0x7a9, 0x750, 0x6a1, 0x541, 0x282, 0x506,
	0x20f, 0x41e, 0x03f, 0x07c, 0x0fb, 0x1f5, 0x3eb, 0x7d4, 0x7ab, 0x755,
	0x6ab, 0x557, 0x2ac, 0x55b, 0x2b4, 0x569, 0x2d0, 0x5a0, 0x340, 0x683,
	0x505, 0x20b, 0x415, 0x028, 0x053, 0x0a6, 0x14e, 0x29d, 0x53a, 0x277,
	0x4ee, 0x1dd, 0x3b8, 0x772, 0x6e4, 0x5c8, 0x390, 0x721, 0x642, 0x487,
	0x10d, 0x21b, 0x435, 0x069, 0x0d1, 0x1a3, 0x347, 0x68c, 0x519, 0x232,
	0x467, 0x0ce, 0x19f, 0x33e, 0x67d, 0x4fa, 0x1f7, 0x3ef, 0x7df, 0x7bd,
	0x77a, 0x6f7, 0x5ec, 0x3da, 0x7b4, 0x768, 0x6d3, 0x5a7, 0x34f, 0x69e,
	0x53d, 0x278, 0x4f2, 0x1e5, 0x3ca, 0x794, 0x728, 0x651, 0x4a3, 0x146,
	0x28e, 0x51f, 0x23c, 0x47b, 0x0f7, 0x1ec, 0x3d9, 0x7b0, 0x763, 0x6c5,
	0x588, 0x312, 0x625, 0x44b, 0x097, 0x12f, 0x25e, 0x4bd, 0x17a, 0x2f7,
	0x5ef, 0x3de, 0x7be, 0x77e, 0x6fd, 0x5fb, 0x3f4, 0x7e8, 0x7d3, 0x7a5,
	0x749, 0x693, 0x525, 0x24b, 0x496, 0x12c, 0x25b, 0x4b6, 0x16d, 0x2d8,
	0x5b3, 0x364, 0x6c9, 0x590, 0x320, 0x641, 0x483, 0x106, 0x20c, 0x41b,
	0x035, 0x06a, 0x0d4, 0x1a9, 0x350, 0x6a3, 0x544, 0x288, 0x511, 0x221,
	0x443, 0x085, 0x10b, 0x214, 0x429, 0x050, 0x0a2, 0x145, 0x28b, 0x515,
	0x22a, 0x454, 0x0aa, 0x156, 0x2af, 0x55e, 0x2be, 0x57e, 0x2ff, 0x5fd,
	0x3fa, 0x7f5, 0x7eb, 0x7d6, 0x7ae, 0x75f, 0x6bc, 0x578, 0x2f0, 0x5e1,
	0x3c2, 0x787, 0x70c, 0x61a, 0x437, 0x06d, 0x0da, 0x1b5, 0x369, 0x6d1,
	0x5a3, 0x344, 0x689, 0x513, 0x225, 0x448, 0x093, 0x124, 0x249, 0x492,
	0x127, 0x24d, 0x499, 0x130, 0x262, 0x4c5, 0x18b, 0x314, 0x62a, 0x457,
	0x0af, 0x15d, 0x2b8, 0x571, 0x2e3, 0x5c5, 0x388, 0x713, 0x627, 0x44f,
	0x09c, 0x138, 0x271, 0x4e1, 0x1c1, 0x380, 0x701, 0x602, 0x405, 0x008,
	0x012, 0x025, 0x04b, 0x095, 0x12a, 0x255, 0x4aa, 0x154, 0x2aa, 0x554,
	0x2a8, 0x551, 0x2a3, 0x547, 0x28d, 0x51a, 0x237, 0x46d, 0x0d8, 0x1b1,
	0x363, 0x6c7, 0x58c, 0x318, 0x632, 0x464, 0x0cb, 0x195, 0x328, 0x652,
	0x4a6, 0x14d, 0x298, 0x530, 0x261, 0x4c0, 0x181, 0x302, 0x604, 0x40b,
	0x014, 0x02b, 0x057, 0x0ac, 0x158, 0x2b3, 0x567, 0x2cc, 0x599, 0x332,
	0x664, 0x4c8, 0x193, 0x326, 0x64e, 0x49e, 0x13f, 0x27e, 0x4fd, 0x1f9,
	0x3f2, 0x7e7, 0x7ce, 0x79c, 0x73b, 0x674, 0x4e9, 0x1d3, 0x3a5, 0x74a,
	0x697, 0x52e, 0x25c, 0x4b9, 0x171, 0x2e0, 0x5c0, 0x382, 0x705, 0x608,
	0x413, 0x027, 0x04e, 0x09e, 0x13c, 0x27a, 0x4f6, 0x1ee, 0x3dd, 0x7ba,
	0x775, 0x6ea, 0x5d4, 0x3a9, 0x752, 0x6a4, 0x54b, 0x294, 0x529, 0x253,
	0x4a5, 0x149, 0x293, 0x526, 0x24f, 0x49d, 0x13b, 0x275, 0x4ea, 0x1d6,
	0x3ae, 0x75d, 0x6b9, 0x572, 0x2e6, 0x5ce, 0x39f, 0x73d, 0x67a, 0x4f5,
	0x1eb, 0x3d7, 0x7ac, 0x75b, 0x6b7, 0x56e, 0x2de, 0x5bc, 0x378, 0x6f1,
	0x5e3, 0x3c7, 0x78d, 0x71a, 0x634, 0x46b, 0x0d6, 0x1ac, 0x35b, 0x6b5,
	0x56b, 0x2d4, 0x5aa, 0x357, 0x6ac, 0x559, 0x2b1, 0x562, 0x2c6, 0x58e,
	0x31d, 0x638, 0x472, 0x0e4, 0x1c8, 0x393, 0x725, 0x648, 0x491, 0x123,
	0x247, 0x48f, 0x11f, 0x23f, 0x47f, 0x0fc, 0x1fa, 0x3f7, 0x7ed, 0x7d9,
	0x7b2, 0x766, 0x6ce, 0x59f, 0x33d, 0x678, 0x4f1, 0x1e0, 0x3c1, 0x782,
	0x706, 0x60d, 0x418, 0x031, 0x060, 0x0c2, 0x186, 0x30c, 0x619, 0x432,
	0x066, 0x0cc, 0x19a, 0x335, 0x66a, 0x4d4, 0x1ab, 0x354, 0x6a9, 0x553,
	0x2a6, 0x54d, 0x29b, 0x535, 0x26b, 0x4d7, 0x1ae, 0x35f, 0x6be, 0x57d,
	0x2fb, 0x5f7, 0x3ec, 0x7da, 0x7b6, 0x76d, 0x6d8, 0x5b1, 0x361, 0x6c3,
	0x586, 0x30e, 0x61d, 0x438, 0x070, 0x0e2, 0x1c6, 0x38f, 0x71d, 0x63b,
	0x477, 0x0ef, 0x1de, 0x3bd, 0x779, 0x6f2, 0x5e7, 0x3cc, 0x79b, 0x734,
	0x669, 0x4d0, 0x1a0, 0x342, 0x687, 0x50e, 0x21d, 0x43b, 0x075, 0x0e9,
	0x1d0, 0x3a1, 0x741, 0x680, 0x500, 0x201, 0x403, 0x007, 0x00e, 0x01c,
	0x039, 0x073, 0x0e7, 0x1cd, 0x399, 0x732, 0x666, 0x4cc, 0x198, 0x330,
	0x661, 0x4c3, 0x185, 0x308, 0x612, 0x425, 0x048, 0x090, 0x121, 0x242,
	0x485, 0x108, 0x211, 0x423, 0x046, 0x08c, 0x119, 0x230, 0x463, 0x0c5,
	0x189, 0x311, 0x620, 0x440, 0x081, 0x100, 0x203, 0x407, 0x00d, 0x018,
	0x032, 0x064, 0x0c8, 0x190, 0x323, 0x644, 0x489, 0x110, 0x223, 0x447,
	0x08e, 0x11d, 0x23b, 0x474, 0x0ea, 0x1d5, 0x3ab, 0x756, 0x6ae, 0x55c,
	0x2ba, 0x575, 0x2e9, 0x5d2, 0x3a7, 0x74e, 0x69d, 0x539, 0x272, 0x4e5,
	0x1cb, 0x397, 0x72e, 0x65f, 0x4be, 0x17e, 0x2fc, 0x5f9, 0x3f0, 0x7e3,
	0x7c4, 0x78b, 0x715, 0x629, 0x453, 0x0a5, 0x14b, 0x296, 0x52d, 0x258,
	0x4b2, 0x166, 0x2cf, 0x59d, 0x339, 0x672, 0x4e6, 0x1cf, 0x39d, 0x738,
	0x671, 0x4e3, 0x1c5, 0x38a, 0x716, 0x62d, 0x458, 0x0b3, 0x164, 0x2ca,
	0x596, 0x32f, 0x65d, 0x4ba, 0x175, 0x2ea, 0x5d6, 0x3ac, 0x758, 0x6b2,
	0x564, 0x2c9, 0x593, 0x324, 0x64a, 0x495, 0x128, 0x250, 0x4a1, 0x142,
	0x284, 0x508, 0x213, 0x426, 0x04c, 0x09a, 0x136, 0x26c, 0x4d9, 0x1b2,
	0x366, 0x6cd, 0x59b, 0x336, 0x66f, 0x4df, 0x1bc, 0x37b, 0x6f4, 0x5e8,
	0x3d1, 0x7a3, 0x747, 0x68f, 0x51c, 0x238, 0x471, 0x0e1, 0x1c2, 0x385,
	0x70a, 0x615, 0x42a, 0x055, 0x0a9, 0x152, 0x2a4, 0x548, 0x290, 0x523,
	0x244, 0x48b, 0x115, 0x229, 0x450, 0x0a1, 0x141, 0x280, 0x503, 0x204,
	0x408, 0x010, 0x021, 0x041, 0x082, 0x104, 0x208, 0x410, 0x023, 0x044,
	0x088, 0x113, 0x227, 0x44d, 0x099, 0x133, 0x267, 0x4cf, 0x19c, 0x33b,
	0x677, 0x4ed, 0x1d8, 0x3b2, 0x764, 0x6cb, 0x595, 0x32b, 0x657, 0x4ac,
	0x15a, 0x2b6, 0x56c, 0x2da, 0x5b6, 0x36f, 0x6df, 0x5bf, 0x37c, 0x6fb,
	0x5f5, 0x3e8, 0x7d1, 0x7a1, 0x742, 0x684, 0x50a, 0x217, 0x42c, 0x05b,
	0x0b4, 0x16a, 0x2d6, 0x5af, 0x35c, 0x6ba, 0x577, 0x2ed, 0x5d8, 0x3b0,
	0x761, 0x6c0, 0x582, 0x304, 0x60a, 0x416, 0x02d, 0x059, 0x0b0, 0x161,
	0x2c0, 0x580, 0x301, 0x600, 0x400, 0x003, 0x005, 0x00b, 0x017, 0x02e,
	0x05d, 0x0bb, 0x177, 0x2ef, 0x5dd, 0x3ba, 0x776, 0x6ee, 0x5df, 0x3be,
	0x77d, 0x6f8, 0x5f1, 0x3e2, 0x7c7, 0x78f, 0x71e, 0x63f, 0x47c, 0x0f8,
	0x1f0, 0x3e0, 0x7c3, 0x784, 0x709, 0x610, 0x420, 0x042, 0x086, 0x10e,
	0x21e, 0x43e, 0x07f, 0x0fe, 0x1ff, 0x3fd, 0x7fa, 0x7f7, 0x7ef, 0x7dc,
	0x7b9, 0x771, 0x6e1, 0x5c3, 0x386, 0x70e, 0x61f, 0x43d, 0x07b, 0x0f5,
	0x1e8, 0x3d2, 0x7a6, 0x74d, 0x698, 0x532, 0x264, 0x4cb, 0x197, 0x32d,
	0x659, 0x4b1, 0x163, 0x2c4, 0x58b, 0x317, 0x62e, 0x45c, 0x0b8, 0x173,
	0x2e5, 0x5cb, 0x394, 0x72b, 0x654, 0x4a9, 0x151, 0x2a0, 0x543, 0x286,
	0x50d, 0x218, 0x430, 0x062, 0x0c6, 0x18d, 0x31b, 0x636, 0x46e, 0x0dd,
	0x1bb, 0x374, 0x6e9, 0x5d1, 0x3a2, 0x744, 0x68a, 0x516, 0x22e, 0x45f,
	0x0bd, 0x178, 0x2f2, 0x5e4, 0x3c8, 0x790, 0x722, 0x646, 0x48c, 0x11b,
	0x235, 0x468, 0x0d3, 0x1a7, 0x34c, 0x69b, 0x537, 0x26e, 0x4dd, 0x1b8,
	0x371, 0x6e3, 0x5c7, 0x38c, 0x719, 0x630, 0x461, 0x0c1, 0x183, 0x307,
	0x60e, 0x41c, 0x03a, 0x076, 0x0ed, 0x1da, 0x3b7, 0x76e, 0x6dd, 0x5ba,
	0x376, 0x6ed, 0x5da, 0x3b4, 0x76a, 0x6d6, 0x5ad, 0x358, 0x6b1, 0x561,
	0x2c2, 0x584, 0x30b, 0x616, 0x42e, 0x05f, 0x0bf, 0x17c, 0x2f8, 0x5f2,
	0x3e6, 0x7cc, 0x799, 0x730, 0x662, 0x4c6, 0x18f, 0x31e, 0x63c, 0x479,
	0x0f2, 0x1e6, 0x3ce, 0x79e, 0x73e, 0x67e, 0x4ff, 0x1fc, 0x3f8, 0x7f0,
	0x7e0, 0x7c0, 0x780, 0x702, 0x606, 0x40e, 0x01f, 0x03c, 0x078, 0x0f1,
	0x1e2, 0x3c4, 0x789, 0x710, 0x622, 0x445, 0x08b, 0x116, 0x22d, 0x45a,
	0x0b6, 0x16f, 0x2dd, 0x5b8, 0x373, 0x6e6, 0x5cd, 0x39b, 0x737, 0x66d,
	0x4db, 0x1b6, 0x36c, 0x6db, 0x5b5, 0x36a, 0x6d4, 0x5a8, 0x353, 0x6a7,
	0x54f, 0x29f, 0x53f, 0x27c, 0x4f8, 0x1f3, 0x3e4, 0x7c8, 0x792, 0x727,
	0x64d, 0x49b, 0x134, 0x269, 0x4d3, 0x1a5, 0x349, 0x691, 0x521, 0x240,
	0x480, 0x102, 0x206, 0x40d, 0x01b, 0x037, 0x06e, 0x0de, 0x1be, 0x37e,
	0x6fe, 0x5fe, 0x3fe,
};

static int cacode(int chip, int tap1, int tap2)
{
	short state = ca_code_states[chip];
	return (state ^ (state >> tap1) ^ (state >> tap2)) & 1;
}

static void read_samples(fftw_complex *data, unsigned int data_len)
{
	unsigned int i;
	float buf[2];
	for(i = 0; i < data_len; ++i)
	{
		fread(buf, sizeof(float), 2, stdin);
		data[i][0] = buf[0];
		data[i][1] = buf[1];
	}

	if(TRACE)
	{
		printf("# input data\n");
		for(i = 0; i < data_len; ++i)
			printf("%f\t%f\n", data[i][0], data[i][1]);
		printf("\n");
	}

	fftw_plan p = fftw_plan_dft_1d(data_len, data, data, FFTW_FORWARD, FFTW_ESTIMATE | FFTW_DESTROY_INPUT);
	fftw_execute(p);
	fftw_destroy_plan(p);

	if(TRACE)
		printf("# input data FFT\n");
	for(i = 0; i < data_len; ++i)
	{
		if(TRACE)
			printf("%f\t%f\n", data[i][0], data[i][1]);
		/* precompute the complex conjugate of the data FFT */
		data[i][1] = -data[i][1];
	}
	if(TRACE)
		printf("\n");
}

static void complex_mul(fftw_complex to, fftw_complex a, fftw_complex b)
{
	to[0] = a[0] * b[0] - a[1] * b[1];
	to[1] = a[1] * b[0] + a[0] * b[1];
}

static void complex_conj_mul(fftw_complex to, fftw_complex a, fftw_complex b)
{
	to[0] = a[0] * b[0] + a[1] * b[1];
	to[1] = a[1] * b[0] - a[0] * b[1];
}

static void update_stats(struct signal_strength *stats, double bin_width, int shift, double phase, double snr_0, double snr_1, double snr_2)
{
	double shift_correction;
	/* ignore this sample if it is not a local peak */
	if(snr_0 > snr_1 || snr_2 > snr_1)
		return;
	/* take only the highest peak */
	if(snr_1 <= stats->snr)
		return;

	/* do a quadratic interpolation of the three points around this peak */
	/* XXX: there's no reason to believe the peaks are parabolic. */
	shift_correction = 0.5 * (snr_0 - snr_2) / (snr_0 - 2 * snr_1 + snr_2);
	stats->snr = snr_1 - 0.25 * (snr_0 - snr_2) * shift_correction;
	stats->doppler = (shift + shift_correction) * bin_width;
	stats->phase = phase;
}

static struct signal_strength check_satellite(unsigned int sample_freq, fftw_complex *data_fft, unsigned int data_fft_len, int sv)
{
	struct signal_strength stats;
	const unsigned int len = sample_freq / 1000;
	const unsigned int fft_len = len / 2 + 1;
	fftw_complex *prod = fftw_malloc(sizeof(fftw_complex) * len);
	void *ca_buf = fftw_malloc(sizeof(fftw_complex) * fft_len);
	double *ca_samples = ca_buf;
	fftw_complex *ca_fft = ca_buf;
	const double samples_per_chip = sample_freq / 1023e3;
	const int max_shift = 5000 * data_fft_len / sample_freq;
	const double bin_width = (double) sample_freq / data_fft_len;
	double snr_1 = 0, snr_2 = 0, best_phase_1 = 0;
	unsigned int i;
	int shift;
	fftw_plan fft = fftw_plan_dft_r2c_1d(len, ca_samples, ca_fft, FFTW_ESTIMATE | FFTW_DESTROY_INPUT);
	fftw_plan ifft = fftw_plan_dft_1d(len, prod, prod, FFTW_BACKWARD, FFTW_ESTIMATE | FFTW_DESTROY_INPUT);

	for(i = 0; i < len; ++i)
		ca_samples[i] = cacode((int) (i / samples_per_chip), SV[sv].T1, SV[sv].T2) ? 1 : -1;

	fftw_execute(fft);
	fftw_destroy_plan(fft);

	if(TRACE)
	{
		printf("# SV %d C/A code FFT\n", SV[sv].PRN);
		for(i = 0; i < fft_len; ++i)
			printf("%f\t%f\n", ca_fft[i][0], ca_fft[i][1]);
		printf("\n");
	}

	if(TRACE)
		printf("# SV %d correlation\n", SV[sv].PRN);
	stats.snr = 0;
	for(shift = -max_shift; shift <= max_shift; ++shift)
	{
		const double doppler = shift * bin_width;
		double max_pwr = 0, tot_pwr = 0, best_phase = 0, snr;
		for(i = 0; i < len / 2; ++i)
		{
			complex_mul(prod[i], data_fft[(i * (data_fft_len / len) + shift + data_fft_len) % data_fft_len], ca_fft[i]);
			complex_conj_mul(prod[len - 1 - i], data_fft[((len - 1 - i) * (data_fft_len / len) + shift + data_fft_len) % data_fft_len], ca_fft[i + 1]);
		}

		fftw_execute(ifft);

		for(i = 0; i < len; ++i)
		{
			double pwr = prod[i][0] * prod[i][0] + prod[i][1] * prod[i][1];
			double phase = i * (1023.0 / len);
			if(TRACE)
				printf("%f\t%f\t%f\n", doppler, phase, pwr);
			if(pwr > max_pwr)
			{
				max_pwr = pwr;
				best_phase = phase;
			}
			tot_pwr += pwr;
		}

		snr = max_pwr / (tot_pwr / len);
		update_stats(&stats, bin_width, shift - 1, best_phase_1, snr_2, snr_1, snr);
		if(TRACE)
			printf("# best for doppler %f: code phase %f, S/N %f\n", doppler, best_phase, snr);

		snr_2 = snr_1;
		snr_1 = snr;
		best_phase_1 = best_phase;
	}
	update_stats(&stats, bin_width, max_shift, best_phase_1, snr_2, snr_1, 0);
	if(TRACE)
		printf("\n");

	fftw_destroy_plan(ifft);
	fftw_free(ca_buf);
	fftw_free(prod);
	return stats;
}

int main()
{
	const unsigned int sample_freq = 4000000;
	const unsigned int data_len = sample_freq * 20 / 1000;
	fftw_complex *data = fftw_malloc(sizeof(fftw_complex) * data_len);
	struct signal_strength signals[sizeof SV / sizeof *SV];
	int i;

	read_samples(data, data_len);
	for(i = 0; i < (sizeof SV / sizeof *SV); ++i)
		signals[i] = check_satellite(sample_freq, data, data_len, i);

	printf("# SV, S/N ratio, doppler shift (Hz), phase (chips)\n");
	for(i = 0; i < (sizeof SV / sizeof *SV); ++i)
		printf("%d\t%f\t%f\t%f\n", SV[i].PRN, signals[i].snr, signals[i].doppler, signals[i].phase);
	printf("\n");

	fftw_free(data);
	fftw_cleanup();
	return 0;
}
